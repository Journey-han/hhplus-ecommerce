# 1. 동시성 이슈가 발생 가능한 시나리오

## 1.1. 상품 재고 차감 📤
- 여러 사용자가 동시에 같은 상품에 대해 주문할 경우 상품 재고를 차감될 때 동시성 이슈가 발생할 수 있다.
### 문제 : 
- 재고관리가 빠르게 되지 않으면 재고가 없는 상품도 주문할 수 있는 문제가 생길 수 있다.

## 1.2. 상품 재고 복원 📥
- 여러 사용자가 동시에 결제에 실패하여 상품 재고를 복원해야할 때 동시성 이슈가 발생할 수 있다.
### 문제  : 
- 상품 재고 복원이 동시에 일어날 경우 재고 관리에 차질이 생길 수 있다.

## 1.3. 포인트 충전 💰
- 각각 개인의 사용자 ID로 포인트를 충전하기 때문에 동시성 이슈가 발생할 가능성은 낮다.
### 문제 : 
- 서버이슈나 네트워크장애로 인해 클라이언트에게 충전 결과가 바로 넘어가지 않았을 경우, 사용자가 여러번 충전을 시도할 수 있다.
### 해결 : 
- 포인트가 중복으로 충전되지않게 처리해야한다.

## 1.4. 결제 및 포인트 차감 💸
- 포인트 차감은 AP가 중복으로 호출하여 포인트가 중복으로 차감될 수 있다.
- - 다수의 사용자가 결제할 때 결제 상태 업데이트와 금액 차감이 동시 실행될 경우.
### 문제 : 
- 중복호출(따닥이슈)로 인한 포인트가 중복 차감
### 해결 : 
- 멱등성보장을 위해 동일한 트랜잭션에 대해서는 한번만 실행되어야하고 중복실행시 결과는 동일해야한다.

---

# 2. 가능한 동시성 제어 방식
- DB 데이터에 동시 접근하는 것을 제어해서 동시성 이슈를 해결하는 방법이다.

## 2.1. 비관적 락 (Pessimistic Lock) 🔒
- 데이터를 읽을 때부터 해당 데이터에 대한 락을 걸어 다른 트랜잭션이 해당 데이터를 변경할 수 없다.
- 트랜잭션이 시작될 때 Shared Lock(공유 락) 또는 Exclusive Lock(배타 락)을 걸고 시작하는 방법이다.
- 동시 요청에서 순차로 진행될 때 성공할 수 있는 요청이라면 성공시키는 케이스에 적합하다.
### 장점 :
- 동시성 문제를 확실하게 방지하여 데이터 일관성을 보장된다.
### 단점 :
- 트랜잭션이 작업중이면 다른 트랜잭션은 대기하고 있어야 하므로 성능이 저하될수 있다.
- 트랜잭션 작업이 정상 종료되지 않으면 다른 트랜잭션 작업들이 무한정 wait 상태에 빠지게돼 교착상태(Deadlock)발생 가능성이 있다.
### 구현 복잡도 :
- **난이도 레벨** :  Low ~ Middle
- 락 설정은 쉬운편이나 충돌이 잦은 경우 구현 복잡도가 증가한다.
- 트랜잭션 범위를 정확하게 정의해야한다.
- 데드락 발생 방지 로직도 고려해야한다.
### 성능 :
- **성능 레벨** : Low
- 동시에 처리할 수 있는 작업이 줄어들기 때문에 성능이 저하된다.
### 효율성 :
- **효율성 레벨** : Middle
- 데이터를 읽을 때부터 해당 데이터에 대한 락을 걸기 때문에 충돌이 일어날 가능이 높은 경우 효율적으로 사용할 수 있다.
### 적용 사례 : 
- 동일 데이터에 대한 업데이트가 빈번하고 충돌 발생이 자주 일어나는 경우에 적합하다.

## 2.2 낙관적 락 (Optimistic Lock) 🔓
- 데이터에 대한 접근을 미리 제한하지 않는다.
- 데이터를 업데이트할 때만 이전 데이터와 현재 데이터를 비교하여 충돌 여부를 판단한다.
- DB에 대한 변경이 드물게 발생하고 충돌 가능성이 낮은 환경에서 유용하다.
### 장점 :
- 한 트랜잭션이 작업중에 다른 트랜잭션이 영향을 받지 않기 때문에 성능이 좋다.
- 데이터를 읽는 동안 다른 트랜잭션이 해당 데이터를 변경할 수 있어 데드락 발생 가능성이 낮다.
- 여러 사용자가 동시에 접근할 수 있어 동시성을 높이는데 유리하다. 
### 단점 : 
- 충돌 발생 시 데이터를 다시 읽고, 업데이트 시켜야 하는 추가적인 로직을 구전해야한다. (롤백과 재시도)
- 충돌을 해결하기 위해선 충돌 발생 시점부터 트랜잭션을 다시 시작해야한다.
### 구현 복잡도 :
- **난이도 레벨** :  Middle
- 데이터 일관성을 보장하려면 버전 번호를 사용하여 데이터가 업데이트 될 때마다 버전을 증가시키고, 업데이트 시점에서 버전을 검사하여 충돌을 감지하여야 한다.
- 재시도 로직을 추가적으로 구현해야한다.
### 성능 :
- **성능 레벨** : High
- 락 대기 시간이 없기 때문에 충돌 가능성이 낮은 환경에서 성능이 좋다. 
### 효율성 :
- **효율성 레벨** : High
- 락을 걸어 트랜잭션이 대기하지 않아 데드락발생 가능성이 낮기 때문에 효율성이 좋다.
### 적용 사례 : 
- 데이터 충돌이 드물고, 대부분의 트랜잭션이 성공적으로 수행 될 작업에 적합하다.

## 2.3. 분산 락 (Redis)📕
- Remote Dictionary Server의 약자. Key-Value 쌍의 해시 맵과 같은 구조를 가진 비관계형 DBMS이다.
- 오픈 소스 기반으로 인-메모리 데이터 구조 저장소로 메모리에 데이터를 저장한다.
### 장점 : 
- 모든 데이터가 메모리에 저장되어 대기 시간을 낮춰 작업 처리량을 높인다.
- 데이터 처리 속도가 빨라 성능이 좋다.
- 싱글 스레드 방식을 사용하여 한 번에 하나의 명령어만 처리한다 → 경쟁 상태가 거의 발생하지 않는다.
### 단점 : 
- 추가적인 러닝 곡선이 필요하다.
- 코드의 복잡성이 증가할 수 있다.
- 서버 사이에서 락을 관리하기 위해 네트워크 통신을 필요로 하다.
- 네트워크 통신은 로컬 네트워크보다 훨씬 느리기 때문에 락 관리에 필요한 시간이 오래 걸릴 수 있다.
### 구현 복잡도 :
- **난이도 레벨** :  Middle ~ High
- 구현하고 유지보수하는 것이 복잡하다. → 오류 발생시 시스템 전체에 영향을 줄 수 있다.
- 락의 획득과 비즈니스 로직 결합을 막기 위해 트랜잭션을 따로 분리해야한다.
- 네트워크 통신을 통해 락을 획득한다면 요청 유실에 대한 처리도 구현해야한다.
- 재시도 로직을 추가적으로 구현해야한다. 
### 성능 :
- **성능 레벨** : High
- 다중 서버 환경에서의 동시성 문제를 해결할 수 있다.
### 효율성 :
- **효율성 레벨** : High
- 서비스가 확장되어도 일관된 동시성 제어가 가능하다.
### 적용 사례 : 
- 다중 인스턴스에서 동일한 리소스에 대해 락을 걸어야 하는 경우 적합하다.

## 2.4. Kafka𐄝
- 메시지(데이터)를 카프카에게 보내고, 가져오는 프로듀서와 컨슈머를 분리하여 사용한다.
- Queue 성질과 비슷하게 오래된 메세지부터 읽지만, 레코드를 읽어도 사라지지 않는다. → 실제 파일시스템에 데이터가 저장되기 때문에
- 컨슈머 처리가 늦거나 카프카클러스터에 문제가 생겨도 메세지 손실이 발생하지 않는다.
### 장점 : 
- 처리 순서를 보장(FIFO)해 특정 데이터에 대한 동시 접근 문제를 해결 할 수 있다.
- 디스크에 메시지를 저장하고 유지하기 때문에 메시지 손실 없이 작업이 가능하다.
### 단점 : 
- 구현의 복잡성이 증가할 수 있다.
- 이벤트 처리 지연 발생이 생길 가능성이 있다.
### 구현 복잡도 :
- **난이도 레벨** :  High
- 프로듀서 및 컨슈머 설정, 이벤트 흐름 설계, 메세지 중복 방지, 이벤트 순서 보장 등의 추가 구현 로직이 필요하다.
- 손실이나 중복없이 순서대로 메세지를 전송하는 것은 구현 난이도가 높고 비용이 많이 들 수 있다.
### 성능 :
- **성능 레벨** : High
- 대규모 데이터를 신속하게 처리할 수 있다.
- 자원을 전부 해당 클러스터에 집중 시켜 신뢰성과 성능을 극대화 시키는 전략을 갖고있다.
### 효율성 :
- **효율성 레벨** : Middle
- 서버 사이에서 락을 관리하기 위해 네트워크 통신을 필요로 하다.
- 네트워크 통신은 로컬 네트워크보다 훨씬 느리기 때문에 락 관리에 필요한 시간이 오래 걸릴 수 있다.
- 시스템별로 카프카 클러스터를 준비해야한다면 운영 유지보수 비용이 증가할 수 있다.
### 적용 사례 : 
- 대규모 분산 시스템에서 데이터의 일관성을 보장하면서 높은 처리량이 필요한 경우 적합하다.

---

# 3. 시나리오에 DB Lock 적용하기
## 3.1. 상품 재고 차감
### 방법 : 
- 비관적 락 사용
### 이유 :
- 재고 차감은 데이터의 일관성이 보장되어야 하기 때문에 비관적 락을 사용해 충돌 방지를 우선 적용
### 고도화 : 
- 향후 Redis를 사용하여 실시간 요구 사항을 충족시키는 것으로 고도화 예정
- 장기적으로 Kafaka를 사용해 시스템 확장성을 높일 수 있도록 학습 희망

## 3.2. 상품 재고 복원
### 방법 :
- 비관적 락 사용
### 이유 : 
- 다중 사용자가 동시에 결제 실패시 상품 재고가 복원되어야 할 수 있기 때문에
### 고도화 : 
- Redis로 재고 복원 이벤트를 빠르게 처리할 수 있다.

## 3.3. 포인트 충전
### 방법 : 
- 낙관적 락 사용
### 이유 : 
- 모든 사용자고 동시에 포인트 충전하는 상황은 적기 때문에
### 고도화 :
- Kafka를 통해 포인트 충전/차감 이벤트를 비동기적으로 전송하여 처리할 수 있다.

## 3.4. 결제 및 포인트 차감
### 방법 : 
- 비관적 락 사용
### 이유 : 
- 결제 과정 동시성 문제를 방지한다.
- 타임세일같은 특수한 상황에서 실시간 동시성이 높을 수 있기 때문에
### 고도화 : 
- Kafka로 결제 이벤트를 처리하여 결제 상태 변경, 관련 이벤트를 분산 시스템에서 처리할 수 있다.